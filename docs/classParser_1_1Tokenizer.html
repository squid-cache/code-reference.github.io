<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Squid Web Cache: Parser::Tokenizer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Squid Web Cache<span id="projectnumber">&#160;master</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classParser_1_1Tokenizer.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classParser_1_1Tokenizer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Parser::Tokenizer Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Parser::Tokenizer:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classParser_1_1Tokenizer__coll__graph.svg" width="439" height="502"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9e33be8144d0d085f34ca59e49dbf602" id="r_a9e33be8144d0d085f34ca59e49dbf602"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a9e33be8144d0d085f34ca59e49dbf602">Tokenizer</a> (const <a class="el" href="classSBuf.html">SBuf</a> &amp;inBuf)</td></tr>
<tr class="separator:a9e33be8144d0d085f34ca59e49dbf602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96fc2860469677296aed171af36b704b" id="r_a96fc2860469677296aed171af36b704b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSBuf.html">SBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a96fc2860469677296aed171af36b704b">buf</a> () const</td></tr>
<tr class="memdesc:a96fc2860469677296aed171af36b704b"><td class="mdescLeft">&#160;</td><td class="mdescRight">yet unparsed data  <br /></td></tr>
<tr class="separator:a96fc2860469677296aed171af36b704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87363b6186ad71bc6298cad565dc7b5a" id="r_a87363b6186ad71bc6298cad565dc7b5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a87363b6186ad71bc6298cad565dc7b5a">parsedSize</a> () const</td></tr>
<tr class="memdesc:a87363b6186ad71bc6298cad565dc7b5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of parsed bytes, including skipped ones  <br /></td></tr>
<tr class="separator:a87363b6186ad71bc6298cad565dc7b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbeaa0c4a0aca89b55f78df9f2ba5ae5" id="r_acbeaa0c4a0aca89b55f78df9f2ba5ae5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#acbeaa0c4a0aca89b55f78df9f2ba5ae5">atEnd</a> () const</td></tr>
<tr class="memdesc:acbeaa0c4a0aca89b55f78df9f2ba5ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the end of the buffer has been reached  <br /></td></tr>
<tr class="separator:acbeaa0c4a0aca89b55f78df9f2ba5ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ffafb00bcee2d6c1ae82df18fc1324" id="r_aa2ffafb00bcee2d6c1ae82df18fc1324"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSBuf.html">SBuf</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#aa2ffafb00bcee2d6c1ae82df18fc1324">remaining</a> () const</td></tr>
<tr class="memdesc:aa2ffafb00bcee2d6c1ae82df18fc1324"><td class="mdescLeft">&#160;</td><td class="mdescRight">the remaining unprocessed section of buffer  <br /></td></tr>
<tr class="separator:aa2ffafb00bcee2d6c1ae82df18fc1324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693d6af8b6b04d0149cad804a352f1ba" id="r_a693d6af8b6b04d0149cad804a352f1ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a693d6af8b6b04d0149cad804a352f1ba">reset</a> (const <a class="el" href="classSBuf.html">SBuf</a> &amp;newBuf)</td></tr>
<tr class="memdesc:a693d6af8b6b04d0149cad804a352f1ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">reinitialize processing for a new buffer  <br /></td></tr>
<tr class="separator:a693d6af8b6b04d0149cad804a352f1ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ff3e4cb6cfbc50f6e66b17bcebc8e1" id="r_a42ff3e4cb6cfbc50f6e66b17bcebc8e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a42ff3e4cb6cfbc50f6e66b17bcebc8e1">token</a> (<a class="el" href="classSBuf.html">SBuf</a> &amp;returnedToken, const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;delimiters)</td></tr>
<tr class="separator:a42ff3e4cb6cfbc50f6e66b17bcebc8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d2b17be6783406bd57dcd98ca3c396" id="r_a10d2b17be6783406bd57dcd98ca3c396"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a10d2b17be6783406bd57dcd98ca3c396">prefix</a> (<a class="el" href="classSBuf.html">SBuf</a> &amp;returnedToken, const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;tokenChars, <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> limit=<a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a>)</td></tr>
<tr class="separator:a10d2b17be6783406bd57dcd98ca3c396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b40c5d7086c9d97b6f1578ba09b898f" id="r_a1b40c5d7086c9d97b6f1578ba09b898f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a1b40c5d7086c9d97b6f1578ba09b898f">suffix</a> (<a class="el" href="classSBuf.html">SBuf</a> &amp;returnedToken, const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;tokenChars, <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> limit=<a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a>)</td></tr>
<tr class="separator:a1b40c5d7086c9d97b6f1578ba09b898f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7292d5cbadfa579332dfdded1d813f56" id="r_a7292d5cbadfa579332dfdded1d813f56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a7292d5cbadfa579332dfdded1d813f56">skipSuffix</a> (const <a class="el" href="classSBuf.html">SBuf</a> &amp;tokenToSkip)</td></tr>
<tr class="separator:a7292d5cbadfa579332dfdded1d813f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af384f3920f50d6662b8f673b4293bde4" id="r_af384f3920f50d6662b8f673b4293bde4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#af384f3920f50d6662b8f673b4293bde4">skip</a> (const <a class="el" href="classSBuf.html">SBuf</a> &amp;tokenToSkip)</td></tr>
<tr class="separator:af384f3920f50d6662b8f673b4293bde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f24858d76e7d309a05799732a599cb" id="r_ad9f24858d76e7d309a05799732a599cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#ad9f24858d76e7d309a05799732a599cb">skip</a> (const char tokenChar)</td></tr>
<tr class="separator:ad9f24858d76e7d309a05799732a599cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d13ed399fdcc03dd21f746e796b64e3" id="r_a3d13ed399fdcc03dd21f746e796b64e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a3d13ed399fdcc03dd21f746e796b64e3">skipOne</a> (const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;discardables)</td></tr>
<tr class="separator:a3d13ed399fdcc03dd21f746e796b64e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739add49ebc47e36cd8ca9b16efc5c84" id="r_a739add49ebc47e36cd8ca9b16efc5c84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a739add49ebc47e36cd8ca9b16efc5c84">skipAll</a> (const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;discardables)</td></tr>
<tr class="separator:a739add49ebc47e36cd8ca9b16efc5c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad540bbab6293aec8dac5f698853a7b3" id="r_aad540bbab6293aec8dac5f698853a7b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#aad540bbab6293aec8dac5f698853a7b3">skipRequired</a> (const char *description, const <a class="el" href="classSBuf.html">SBuf</a> &amp;tokenToSkip)</td></tr>
<tr class="separator:aad540bbab6293aec8dac5f698853a7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c7e3f3973e363e6f9a1f78e04d43be" id="r_aa9c7e3f3973e363e6f9a1f78e04d43be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#aa9c7e3f3973e363e6f9a1f78e04d43be">skipOneTrailing</a> (const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;discardables)</td></tr>
<tr class="separator:aa9c7e3f3973e363e6f9a1f78e04d43be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007e81dbd21db8da6f77d90e9799ea5a" id="r_a007e81dbd21db8da6f77d90e9799ea5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a007e81dbd21db8da6f77d90e9799ea5a">skipAllTrailing</a> (const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;discardables)</td></tr>
<tr class="separator:a007e81dbd21db8da6f77d90e9799ea5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd7d3c2564af4fc0ab4fd1680ac4dd4" id="r_a7fd7d3c2564af4fc0ab4fd1680ac4dd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a7fd7d3c2564af4fc0ab4fd1680ac4dd4">int64</a> (int64_t &amp;result, <a class="el" href="stub__fd_8cc.html#a2f81796204b7bbe80bac6d6599203024">int</a> base=0, bool allowSign=true, <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> limit=<a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a>)</td></tr>
<tr class="separator:a7fd7d3c2564af4fc0ab4fd1680ac4dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c9b4e15b2fdff97292bb46599ec606" id="r_ad4c9b4e15b2fdff97292bb46599ec606"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSBuf.html">SBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#ad4c9b4e15b2fdff97292bb46599ec606">prefix</a> (const char *description, const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;tokenChars, <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> limit=<a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a>)</td></tr>
<tr class="separator:ad4c9b4e15b2fdff97292bb46599ec606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec488c399ddbb66879d446db095b6153" id="r_aec488c399ddbb66879d446db095b6153"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#aec488c399ddbb66879d446db095b6153">udec64</a> (const char *description, <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> limit=<a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a>)</td></tr>
<tr class="memdesc:aec488c399ddbb66879d446db095b6153"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classParser_1_1Tokenizer.html#a7fd7d3c2564af4fc0ab4fd1680ac4dd4">int64()</a> wrapper but limited to unsigned decimal integers (for now)  <br /></td></tr>
<tr class="separator:aec488c399ddbb66879d446db095b6153"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8bce328442a3a568749270ea4c76080f" id="r_a8bce328442a3a568749270ea4c76080f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSBuf.html">SBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a8bce328442a3a568749270ea4c76080f">consume</a> (const <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> n)</td></tr>
<tr class="memdesc:a8bce328442a3a568749270ea4c76080f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience method: consumes up to n bytes, counts, and returns them  <br /></td></tr>
<tr class="separator:a8bce328442a3a568749270ea4c76080f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dfe20ace30cfc46303193fdab5abb79" id="r_a5dfe20ace30cfc46303193fdab5abb79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a5dfe20ace30cfc46303193fdab5abb79">success</a> (const <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> n)</td></tr>
<tr class="memdesc:a5dfe20ace30cfc46303193fdab5abb79"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience method: <a class="el" href="classParser_1_1Tokenizer.html#a8bce328442a3a568749270ea4c76080f" title="convenience method: consumes up to n bytes, counts, and returns them">consume()</a>s up to n bytes and returns their count  <br /></td></tr>
<tr class="separator:a5dfe20ace30cfc46303193fdab5abb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475d32308502ac70daa2c5999e95515e" id="r_a475d32308502ac70daa2c5999e95515e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSBuf.html">SBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a475d32308502ac70daa2c5999e95515e">consumeTrailing</a> (const <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> n)</td></tr>
<tr class="memdesc:a475d32308502ac70daa2c5999e95515e"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience method: consumes up to n last bytes and returns them  <br /></td></tr>
<tr class="separator:a475d32308502ac70daa2c5999e95515e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3170068ba972243a7fc020ce94ee18db" id="r_a3170068ba972243a7fc020ce94ee18db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a3170068ba972243a7fc020ce94ee18db">successTrailing</a> (const <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> n)</td></tr>
<tr class="memdesc:a3170068ba972243a7fc020ce94ee18db"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience method: consumes up to n last bytes and returns their count  <br /></td></tr>
<tr class="separator:a3170068ba972243a7fc020ce94ee18db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71043e213e4bddffe3bd27bc6a80e0b1" id="r_a71043e213e4bddffe3bd27bc6a80e0b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a71043e213e4bddffe3bd27bc6a80e0b1">undoParse</a> (const <a class="el" href="classSBuf.html">SBuf</a> &amp;newBuf, <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> cParsed)</td></tr>
<tr class="memdesc:a71043e213e4bddffe3bd27bc6a80e0b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the buffer and parsed stats to a saved checkpoint  <br /></td></tr>
<tr class="separator:a71043e213e4bddffe3bd27bc6a80e0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1410dfb01c7f2c0f56655991e15b4a12" id="r_a1410dfb01c7f2c0f56655991e15b4a12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSBuf.html">SBuf</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#a1410dfb01c7f2c0f56655991e15b4a12">buf_</a></td></tr>
<tr class="memdesc:a1410dfb01c7f2c0f56655991e15b4a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">yet unparsed input  <br /></td></tr>
<tr class="separator:a1410dfb01c7f2c0f56655991e15b4a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad950974893a15479c433c594984f2cb9" id="r_ad950974893a15479c433c594984f2cb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classParser_1_1Tokenizer.html#ad950974893a15479c433c594984f2cb9">parsed_</a></td></tr>
<tr class="memdesc:ad950974893a15479c433c594984f2cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">bytes successfully parsed, including skipped  <br /></td></tr>
<tr class="separator:ad950974893a15479c433c594984f2cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lexical processor to tokenize a buffer.</p>
<p>Allows arbitrary delimiters and token character sets to be provided by callers.</p>
<p>All methods start from the beginning of the input buffer. Methods returning true consume bytes from the buffer. Methods returning false have no side-effects. </p>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8h_source.html#l00029">29</a> of file <a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9e33be8144d0d085f34ca59e49dbf602" name="a9e33be8144d0d085f34ca59e49dbf602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e33be8144d0d085f34ca59e49dbf602">&#9670;&#160;</a></span>Tokenizer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Parser::Tokenizer::Tokenizer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSBuf.html">SBuf</a> &amp;&#160;</td>
          <td class="paramname"><em>inBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8h_source.html#l00032">32</a> of file <a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acbeaa0c4a0aca89b55f78df9f2ba5ae5" name="acbeaa0c4a0aca89b55f78df9f2ba5ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbeaa0c4a0aca89b55f78df9f2ba5ae5">&#9670;&#160;</a></span>atEnd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Tokenizer::atEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8h_source.html#l00041">41</a> of file <a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a>.</p>

<p class="reference">References <a class="el" href="classParser_1_1Tokenizer.html#a1410dfb01c7f2c0f56655991e15b4a12">buf_</a>, and <a class="el" href="classSBuf.html#a8bda8fe69e451e61946b35c2a2d2340b">SBuf::isEmpty()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAnyP_1_1Uri.html#af4f1d57dbbd057b7f4eae15198d16096">AnyP::Uri::Encode()</a>, <a class="el" href="namespaceProxyProtocol.html#acf6f5f1488b9f9f34d3a00da1217d60d">ProxyProtocol::IntegerToFieldType()</a>, <a class="el" href="classIp_1_1NfMarkConfig.html#abac2c63ad16f3491a92f8a23795927cd">Ip::NfMarkConfig::Parse()</a>, and <a class="el" href="classSecurity_1_1PeerOptions.html#ad7b17f5de855ae7cf528e68d473a24c2">Security::PeerOptions::parseOptions()</a>.</p>

</div>
</div>
<a id="a96fc2860469677296aed171af36b704b" name="a96fc2860469677296aed171af36b704b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96fc2860469677296aed171af36b704b">&#9670;&#160;</a></span>buf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSBuf.html">SBuf</a> Parser::Tokenizer::buf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8h_source.html#l00035">35</a> of file <a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a>.</p>

<p class="reference">References <a class="el" href="classParser_1_1Tokenizer.html#a1410dfb01c7f2c0f56655991e15b4a12">buf_</a>.</p>

<p class="reference">Referenced by <a class="el" href="NfMarkConfig_8cc.html#a4248993a11ae51d7d91fe74cf1a5ed1f">getNfmark()</a>, and <a class="el" href="classTestTokenizer.html#acceb95b5054ba6810f688236f341d3d0">TestTokenizer::testTokenizerInt64()</a>.</p>

</div>
</div>
<a id="a8bce328442a3a568749270ea4c76080f" name="a8bce328442a3a568749270ea4c76080f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bce328442a3a568749270ea4c76080f">&#9670;&#160;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSBuf.html">SBuf</a> Parser::Tokenizer::consume </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00022">22</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="classParser_1_1Tokenizer.html#a1410dfb01c7f2c0f56655991e15b4a12">buf_</a>, <a class="el" href="classSBuf.html#a27c3dd8867d72547428ebb9de5894eeb">SBuf::consume()</a>, <a class="el" href="debug_2Stream_8h.html#ad8cd33a7d75c0efd4d3fd369dc6a8f13">debugs</a>, <a class="el" href="classSBuf.html#a4fdfe954309aa6da19240f11a8f6b583">SBuf::length()</a>, and <a class="el" href="classParser_1_1Tokenizer.html#ad950974893a15479c433c594984f2cb9">parsed_</a>.</p>

</div>
</div>
<a id="a475d32308502ac70daa2c5999e95515e" name="a475d32308502ac70daa2c5999e95515e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a475d32308502ac70daa2c5999e95515e">&#9670;&#160;</a></span>consumeTrailing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSBuf.html">SBuf</a> Parser::Tokenizer::consumeTrailing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00040">40</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="classSBuf.html#a27c3dd8867d72547428ebb9de5894eeb">SBuf::consume()</a>, <a class="el" href="debug_2Stream_8h.html#ad8cd33a7d75c0efd4d3fd369dc6a8f13">debugs</a>, and <a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a>.</p>

</div>
</div>
<a id="a7fd7d3c2564af4fc0ab4fd1680ac4dd4" name="a7fd7d3c2564af4fc0ab4fd1680ac4dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd7d3c2564af4fc0ab4fd1680ac4dd4">&#9670;&#160;</a></span>int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Tokenizer::int64 </td>
          <td>(</td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stub__fd_8cc.html#a2f81796204b7bbe80bac6d6599203024">int</a>&#160;</td>
          <td class="paramname"><em>base</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowSign</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts an unsigned int64_t at the beginning of the buffer.</p>
<p>strtoll(3)-alike function: tries to parse unsigned 64-bit integer at the beginning of the parse buffer, in the base specified by the user or guesstimated; consumes the parsed characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">result</td><td>Output value. Not touched if parsing is unsuccessful. </td></tr>
    <tr><td class="paramname">base</td><td>Specify base to do the parsing in, with the same restrictions as strtoll. Defaults to 0 (meaning guess) </td></tr>
    <tr><td class="paramname">allowSign</td><td>Whether to accept a '+' or '-' sign prefix. </td></tr>
    <tr><td class="paramname">limit</td><td>Maximum count of characters to convert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the parsing was successful </dd></dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00238">238</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="types_8h.html#ad0d744f05898e32d01f73f8af3cd2071">INT64_MAX</a>, <a class="el" href="types_8h.html#ab21f12f372f67b8ff0aa3432336ede67">INT64_MIN</a>, <a class="el" href="classSBuf.html#a4fdfe954309aa6da19240f11a8f6b583">SBuf::length()</a>, <a class="el" href="classSBuf.html#a1af20d84cdd1e4f380c74a08d67d0edb">SBuf::rawContent()</a>, <a class="el" href="xis_8h.html#a4e550bf868f1ece39525744d076e84a2">xisalpha</a>, <a class="el" href="xis_8h.html#a9132acb9b6ad4bf867f4258ff707e7df">xisdigit</a>, and <a class="el" href="xis_8h.html#a2d591b4550924584c6e853865f5c99ed">xisupper</a>.</p>

<p class="reference">Referenced by <a class="el" href="NfMarkConfig_8cc.html#a4248993a11ae51d7d91fe74cf1a5ed1f">getNfmark()</a>, <a class="el" href="namespaceProxyProtocol.html#acf6f5f1488b9f9f34d3a00da1217d60d">ProxyProtocol::IntegerToFieldType()</a>, <a class="el" href="classSecurity_1_1PeerOptions.html#ad7b17f5de855ae7cf528e68d473a24c2">Security::PeerOptions::parseOptions()</a>, and <a class="el" href="classTestTokenizer.html#acceb95b5054ba6810f688236f341d3d0">TestTokenizer::testTokenizerInt64()</a>.</p>

</div>
</div>
<a id="a87363b6186ad71bc6298cad565dc7b5a" name="a87363b6186ad71bc6298cad565dc7b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87363b6186ad71bc6298cad565dc7b5a">&#9670;&#160;</a></span>parsedSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> Parser::Tokenizer::parsedSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8h_source.html#l00038">38</a> of file <a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a>.</p>

<p class="reference">References <a class="el" href="classParser_1_1Tokenizer.html#ad950974893a15479c433c594984f2cb9">parsed_</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceProxyProtocol.html#a276022b31f1ffa89440172bfcf0285b3">ProxyProtocol::Parse()</a>.</p>

</div>
</div>
<a id="ad4c9b4e15b2fdff97292bb46599ec606" name="ad4c9b4e15b2fdff97292bb46599ec606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4c9b4e15b2fdff97292bb46599ec606">&#9670;&#160;</a></span>prefix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSBuf.html">SBuf</a> Parser::Tokenizer::prefix </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;&#160;</td>
          <td class="paramname"><em>tokenChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classParser_1_1Tokenizer.html#a10d2b17be6783406bd57dcd98ca3c396">prefix()</a> wrapper but throws <a class="el" href="classParser_1_1InsufficientInput.html" title="thrown by modern &quot;incremental&quot; parsers when they need more data">InsufficientInput</a> if input contains nothing but the prefix (i.e. if the prefix is not "terminated") </p>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00100">100</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="TextException_8h.html#a2cf020aa9d72c2ec7abef506457b2f9a">TexcHere</a>, and <a class="el" href="sbuf_2Stream_8h.html#a6160c2bd5c3883a54866ccfd670ce4b6">ToSBuf()</a>.</p>

</div>
</div>
<a id="a10d2b17be6783406bd57dcd98ca3c396" name="a10d2b17be6783406bd57dcd98ca3c396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d2b17be6783406bd57dcd98ca3c396">&#9670;&#160;</a></span>prefix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Tokenizer::prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSBuf.html">SBuf</a> &amp;&#160;</td>
          <td class="paramname"><em>returnedToken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;&#160;</td>
          <td class="paramname"><em>tokenChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts all sequential permitted characters up to an optional length limit.</p>
<p><a class="el" href="classNote.html">Note</a> that <a class="el" href="classParser_1_1Tokenizer.html">Tokenizer</a> cannot tell whether the prefix will continue when/if more input data becomes available later.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>one or more characters were found, the sequence (string) is placed in returnedToken </td></tr>
    <tr><td class="paramname">false</td><td>no characters from the permitted set were found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00079">79</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="debug_2Stream_8h.html#ad8cd33a7d75c0efd4d3fd369dc6a8f13">debugs</a>, <a class="el" href="classCharacterSet.html#a96ef24ccef99b2f28d7d45ae9da713f9">CharacterSet::name</a>, and <a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAnyP_1_1Uri.html#af4f1d57dbbd057b7f4eae15198d16096">AnyP::Uri::Encode()</a>, <a class="el" href="classTestTokenizer.html#a3eff8bebecc85a31500e403ecaa7f9fa">TestTokenizer::testTokenizerPrefix()</a>, and <a class="el" href="classTestTokenizer.html#a3fce8bae16533005be83e9bcce91ea3f">TestTokenizer::testTokenizerSkip()</a>.</p>

</div>
</div>
<a id="aa2ffafb00bcee2d6c1ae82df18fc1324" name="aa2ffafb00bcee2d6c1ae82df18fc1324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ffafb00bcee2d6c1ae82df18fc1324">&#9670;&#160;</a></span>remaining()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSBuf.html">SBuf</a> &amp; Parser::Tokenizer::remaining </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8h_source.html#l00044">44</a> of file <a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a>.</p>

<p class="reference">References <a class="el" href="classParser_1_1Tokenizer.html#a1410dfb01c7f2c0f56655991e15b4a12">buf_</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAnyP_1_1Uri.html#af4f1d57dbbd057b7f4eae15198d16096">AnyP::Uri::Encode()</a>, <a class="el" href="classAuth_1_1SchemesConfig.html#a883d0e62996427e007d79c43d050aca2">Auth::SchemesConfig::expand()</a>, <a class="el" href="namespaceProxyProtocol.html#a276022b31f1ffa89440172bfcf0285b3">ProxyProtocol::Parse()</a>, <a class="el" href="classTestTokenizer.html#a3eff8bebecc85a31500e403ecaa7f9fa">TestTokenizer::testTokenizerPrefix()</a>, <a class="el" href="classTestTokenizer.html#a3fce8bae16533005be83e9bcce91ea3f">TestTokenizer::testTokenizerSkip()</a>, and <a class="el" href="classTestTokenizer.html#ad4a5e4939a8746a583c696db326298c3">TestTokenizer::testTokenizerSuffix()</a>.</p>

</div>
</div>
<a id="a693d6af8b6b04d0149cad804a352f1ba" name="a693d6af8b6b04d0149cad804a352f1ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693d6af8b6b04d0149cad804a352f1ba">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::Tokenizer::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSBuf.html">SBuf</a> &amp;&#160;</td>
          <td class="paramname"><em>newBuf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8h_source.html#l00047">47</a> of file <a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a>.</p>

<p class="reference">References <a class="el" href="classParser_1_1Tokenizer.html#a71043e213e4bddffe3bd27bc6a80e0b1">undoParse()</a>.</p>

</div>
</div>
<a id="ad9f24858d76e7d309a05799732a599cb" name="ad9f24858d76e7d309a05799732a599cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f24858d76e7d309a05799732a599cb">&#9670;&#160;</a></span>skip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Tokenizer::skip </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>tokenChar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>skips a given single character</p>
<dl class="section return"><dt>Returns</dt><dd>whether the character was skipped </dd></dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00200">200</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="debug_2Stream_8h.html#ad8cd33a7d75c0efd4d3fd369dc6a8f13">debugs</a>.</p>

</div>
</div>
<a id="af384f3920f50d6662b8f673b4293bde4" name="af384f3920f50d6662b8f673b4293bde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af384f3920f50d6662b8f673b4293bde4">&#9670;&#160;</a></span>skip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Tokenizer::skip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSBuf.html">SBuf</a> &amp;&#160;</td>
          <td class="paramname"><em>tokenToSkip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>skips a given character sequence (string)</p>
<dl class="section return"><dt>Returns</dt><dd>whether the exact character sequence was found and skipped </dd></dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00189">189</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="debug_2Stream_8h.html#ad8cd33a7d75c0efd4d3fd369dc6a8f13">debugs</a>, and <a class="el" href="classSBuf.html#a4fdfe954309aa6da19240f11a8f6b583">SBuf::length()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAnyP_1_1Uri.html#af4f1d57dbbd057b7f4eae15198d16096">AnyP::Uri::Encode()</a>, <a class="el" href="namespaceProxyProtocol.html#acf6f5f1488b9f9f34d3a00da1217d60d">ProxyProtocol::IntegerToFieldType()</a>, <a class="el" href="namespaceProxyProtocol.html#a276022b31f1ffa89440172bfcf0285b3">ProxyProtocol::Parse()</a>, <a class="el" href="namespaceProxyProtocol_1_1One.html#a43df8a8f92ea650044b46cdd6b505cfe">ProxyProtocol::One::Parse()</a>, <a class="el" href="classIp_1_1NfMarkConfig.html#abac2c63ad16f3491a92f8a23795927cd">Ip::NfMarkConfig::Parse()</a>, and <a class="el" href="classTestTokenizer.html#a3fce8bae16533005be83e9bcce91ea3f">TestTokenizer::testTokenizerSkip()</a>.</p>

</div>
</div>
<a id="a739add49ebc47e36cd8ca9b16efc5c84" name="a739add49ebc47e36cd8ca9b16efc5c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739add49ebc47e36cd8ca9b16efc5c84">&#9670;&#160;</a></span>skipAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> Parser::Tokenizer::skipAll </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;&#160;</td>
          <td class="paramname"><em>discardables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Skips all sequential characters from the set, in any order.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of skipped characters </dd></dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00137">137</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="debug_2Stream_8h.html#ad8cd33a7d75c0efd4d3fd369dc6a8f13">debugs</a>, and <a class="el" href="classCharacterSet.html#a96ef24ccef99b2f28d7d45ae9da713f9">CharacterSet::name</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTestTokenizer.html#a3fce8bae16533005be83e9bcce91ea3f">TestTokenizer::testTokenizerSkip()</a>.</p>

</div>
</div>
<a id="a007e81dbd21db8da6f77d90e9799ea5a" name="a007e81dbd21db8da6f77d90e9799ea5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a007e81dbd21db8da6f77d90e9799ea5a">&#9670;&#160;</a></span>skipAllTrailing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> Parser::Tokenizer::skipAllTrailing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;&#160;</td>
          <td class="paramname"><em>discardables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all sequential trailing characters from the set, in any order.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of characters removed </dd></dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00222">222</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="debug_2Stream_8h.html#ad8cd33a7d75c0efd4d3fd369dc6a8f13">debugs</a>, <a class="el" href="classCharacterSet.html#a96ef24ccef99b2f28d7d45ae9da713f9">CharacterSet::name</a>, and <a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAuth_1_1SchemesConfig.html#a883d0e62996427e007d79c43d050aca2">Auth::SchemesConfig::expand()</a>.</p>

</div>
</div>
<a id="a3d13ed399fdcc03dd21f746e796b64e3" name="a3d13ed399fdcc03dd21f746e796b64e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d13ed399fdcc03dd21f746e796b64e3">&#9670;&#160;</a></span>skipOne()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Tokenizer::skipOne </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;&#160;</td>
          <td class="paramname"><em>discardables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Skips a single character from the set.</p>
<dl class="section return"><dt>Returns</dt><dd>whether a character was skipped </dd></dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00161">161</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="debug_2Stream_8h.html#ad8cd33a7d75c0efd4d3fd369dc6a8f13">debugs</a>, and <a class="el" href="classCharacterSet.html#a96ef24ccef99b2f28d7d45ae9da713f9">CharacterSet::name</a>.</p>

<p class="reference">Referenced by <a class="el" href="namespaceProxyProtocol.html#ad1c4c6e697ba52b65aab9c9290c4c8a3">ProxyProtocol::FieldNameToFieldType()</a>, and <a class="el" href="classTestTokenizer.html#a3fce8bae16533005be83e9bcce91ea3f">TestTokenizer::testTokenizerSkip()</a>.</p>

</div>
</div>
<a id="aa9c7e3f3973e363e6f9a1f78e04d43be" name="aa9c7e3f3973e363e6f9a1f78e04d43be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c7e3f3973e363e6f9a1f78e04d43be">&#9670;&#160;</a></span>skipOneTrailing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Tokenizer::skipOneTrailing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;&#160;</td>
          <td class="paramname"><em>discardables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a single trailing character from the set.</p>
<dl class="section return"><dt>Returns</dt><dd>whether a character was removed </dd></dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00211">211</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="debug_2Stream_8h.html#ad8cd33a7d75c0efd4d3fd369dc6a8f13">debugs</a>, and <a class="el" href="classCharacterSet.html#a96ef24ccef99b2f28d7d45ae9da713f9">CharacterSet::name</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTestTokenizer.html#ad4a5e4939a8746a583c696db326298c3">TestTokenizer::testTokenizerSuffix()</a>.</p>

</div>
</div>
<a id="aad540bbab6293aec8dac5f698853a7b3" name="aad540bbab6293aec8dac5f698853a7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad540bbab6293aec8dac5f698853a7b3">&#9670;&#160;</a></span>skipRequired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::Tokenizer::skipRequired </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSBuf.html">SBuf</a> &amp;&#160;</td>
          <td class="paramname"><em>tokenToSkip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>skips a given character sequence (string); does nothing if the sequence is empty</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">exception</td><td>on mismatching prefix or <a class="el" href="classParser_1_1InsufficientInput.html" title="thrown by modern &quot;incremental&quot; parsers when they need more data">InsufficientInput</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00149">149</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="Here_8h.html#ae4d205e9d525856fbdfd44f7eccb309b">Here</a>, <a class="el" href="classSBuf.html#a8bda8fe69e451e61946b35c2a2d2340b">SBuf::isEmpty()</a>, <a class="el" href="classSBuf.html#ada4321ff7578e3fe09ab549fda13508e">SBuf::startsWith()</a>, and <a class="el" href="sbuf_2Stream_8h.html#a6160c2bd5c3883a54866ccfd670ce4b6">ToSBuf()</a>.</p>

</div>
</div>
<a id="a7292d5cbadfa579332dfdded1d813f56" name="a7292d5cbadfa579332dfdded1d813f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7292d5cbadfa579332dfdded1d813f56">&#9670;&#160;</a></span>skipSuffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Tokenizer::skipSuffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSBuf.html">SBuf</a> &amp;&#160;</td>
          <td class="paramname"><em>tokenToSkip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>skips a given suffix character sequence (string) Operates on the trailing end of the buffer.</p>
<p><a class="el" href="classNote.html">Note</a> that <a class="el" href="classParser_1_1Tokenizer.html">Tokenizer</a> cannot tell whether the buffer will gain more data when/if more input becomes available later.</p>
<dl class="section return"><dt>Returns</dt><dd>whether the exact character sequence was found and skipped </dd></dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00172">172</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="debug_2Stream_8h.html#ad8cd33a7d75c0efd4d3fd369dc6a8f13">debugs</a>, <a class="el" href="classSBuf.html#a4fdfe954309aa6da19240f11a8f6b583">SBuf::length()</a>, and <a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTestTokenizer.html#ad4a5e4939a8746a583c696db326298c3">TestTokenizer::testTokenizerSuffix()</a>.</p>

</div>
</div>
<a id="a5dfe20ace30cfc46303193fdab5abb79" name="a5dfe20ace30cfc46303193fdab5abb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dfe20ace30cfc46303193fdab5abb79">&#9670;&#160;</a></span>success()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> Parser::Tokenizer::success </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00033">33</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="classSBuf.html#a4fdfe954309aa6da19240f11a8f6b583">SBuf::length()</a>.</p>

</div>
</div>
<a id="a3170068ba972243a7fc020ce94ee18db" name="a3170068ba972243a7fc020ce94ee18db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3170068ba972243a7fc020ce94ee18db">&#9670;&#160;</a></span>successTrailing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> Parser::Tokenizer::successTrailing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00055">55</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="classSBuf.html#a4fdfe954309aa6da19240f11a8f6b583">SBuf::length()</a>.</p>

</div>
</div>
<a id="a1b40c5d7086c9d97b6f1578ba09b898f" name="a1b40c5d7086c9d97b6f1578ba09b898f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b40c5d7086c9d97b6f1578ba09b898f">&#9670;&#160;</a></span>suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Tokenizer::suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSBuf.html">SBuf</a> &amp;&#160;</td>
          <td class="paramname"><em>returnedToken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;&#160;</td>
          <td class="paramname"><em>tokenChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extracts all sequential permitted characters up to an optional length limit. Operates on the trailing end of the buffer.</p>
<p><a class="el" href="classNote.html">Note</a> that <a class="el" href="classParser_1_1Tokenizer.html">Tokenizer</a> cannot tell whether the buffer will gain more data when/if more input becomes available later.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>one or more characters were found, the sequence (string) is placed in returnedToken </td></tr>
    <tr><td class="paramname">false</td><td>no characters from the permitted set were found </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00117">117</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="classSBuf.html#a27c3dd8867d72547428ebb9de5894eeb">SBuf::consume()</a>, <a class="el" href="classSBuf.html#ab489e62b349e678e32103f5e24de28ea">SBuf::rbegin()</a>, and <a class="el" href="classSBuf.html#aee8bb9585acd71b8d90531a1f662e74c">SBuf::rend()</a>.</p>

<p class="reference">Referenced by <a class="el" href="classTestTokenizer.html#ad4a5e4939a8746a583c696db326298c3">TestTokenizer::testTokenizerSuffix()</a>.</p>

</div>
</div>
<a id="a42ff3e4cb6cfbc50f6e66b17bcebc8e1" name="a42ff3e4cb6cfbc50f6e66b17bcebc8e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ff3e4cb6cfbc50f6e66b17bcebc8e1">&#9670;&#160;</a></span>token()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Parser::Tokenizer::token </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSBuf.html">SBuf</a> &amp;&#160;</td>
          <td class="paramname"><em>returnedToken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classCharacterSet.html">CharacterSet</a> &amp;&#160;</td>
          <td class="paramname"><em>delimiters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Basic strtok(3): Skips all leading delimiters (if any), extracts all characters up to the next delimiter (a token), and skips all trailing delimiters (at least one must be present).</p>
<p>Want to extract delimiters? Use <a class="el" href="classParser_1_1Tokenizer.html#a10d2b17be6783406bd57dcd98ca3c396">prefix()</a> instead.</p>
<p><a class="el" href="classNote.html">Note</a> that <a class="el" href="classParser_1_1Tokenizer.html">Tokenizer</a> cannot tell whether the trailing delimiters will continue when/if more input data becomes available later.</p>
<dl class="section return"><dt>Returns</dt><dd>true if found a non-empty token followed by a delimiter </dd></dl>

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00061">61</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="debug_2Stream_8h.html#a2d06cfc291c938231d74e9b2a54b4a6a">DBG_DATA</a>, <a class="el" href="debug_2Stream_8h.html#ad8cd33a7d75c0efd4d3fd369dc6a8f13">debugs</a>, <a class="el" href="classCharacterSet.html#a96ef24ccef99b2f28d7d45ae9da713f9">CharacterSet::name</a>, and <a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a>.</p>

<p class="reference">Referenced by <a class="el" href="classAuth_1_1SchemesConfig.html#a883d0e62996427e007d79c43d050aca2">Auth::SchemesConfig::expand()</a>, and <a class="el" href="classTestTokenizer.html#a5dc0a781d9c9bf6cbfa02ae38c6020d8">TestTokenizer::testTokenizerToken()</a>.</p>

</div>
</div>
<a id="aec488c399ddbb66879d446db095b6153" name="aec488c399ddbb66879d446db095b6153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec488c399ddbb66879d446db095b6153">&#9670;&#160;</a></span>udec64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t Parser::Tokenizer::udec64 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td>
          <td class="paramname"><em>limit</em> = <code><a class="el" href="classSBuf.html#a1db91b2f039b38745f7d73b56ac9311f">SBuf::npos</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8cc_source.html#l00315">315</a> of file <a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a>.</p>

<p class="reference">References <a class="el" href="TextException_8h.html#a2cf020aa9d72c2ec7abef506457b2f9a">TexcHere</a>, and <a class="el" href="sbuf_2Stream_8h.html#a6160c2bd5c3883a54866ccfd670ce4b6">ToSBuf()</a>.</p>

</div>
</div>
<a id="a71043e213e4bddffe3bd27bc6a80e0b1" name="a71043e213e4bddffe3bd27bc6a80e0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71043e213e4bddffe3bd27bc6a80e0b1">&#9670;&#160;</a></span>undoParse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Parser::Tokenizer::undoParse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSBuf.html">SBuf</a> &amp;&#160;</td>
          <td class="paramname"><em>newBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a>&#160;</td>
          <td class="paramname"><em>cParsed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8h_source.html#l00173">173</a> of file <a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a>.</p>

<p class="reference">References <a class="el" href="classParser_1_1Tokenizer.html#a1410dfb01c7f2c0f56655991e15b4a12">buf_</a>, and <a class="el" href="classParser_1_1Tokenizer.html#ad950974893a15479c433c594984f2cb9">parsed_</a>.</p>

<p class="reference">Referenced by <a class="el" href="classParser_1_1Tokenizer.html#a693d6af8b6b04d0149cad804a352f1ba">reset()</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1410dfb01c7f2c0f56655991e15b4a12" name="a1410dfb01c7f2c0f56655991e15b4a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1410dfb01c7f2c0f56655991e15b4a12">&#9670;&#160;</a></span>buf_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSBuf.html">SBuf</a> Parser::Tokenizer::buf_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8h_source.html#l00176">176</a> of file <a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="classParser_1_1Tokenizer.html#acbeaa0c4a0aca89b55f78df9f2ba5ae5">atEnd()</a>, <a class="el" href="classParser_1_1Tokenizer.html#a96fc2860469677296aed171af36b704b">buf()</a>, <a class="el" href="classParser_1_1Tokenizer.html#a8bce328442a3a568749270ea4c76080f">consume()</a>, <a class="el" href="classParser_1_1Tokenizer.html#aa2ffafb00bcee2d6c1ae82df18fc1324">remaining()</a>, and <a class="el" href="classParser_1_1Tokenizer.html#a71043e213e4bddffe3bd27bc6a80e0b1">undoParse()</a>.</p>

</div>
</div>
<a id="ad950974893a15479c433c594984f2cb9" name="ad950974893a15479c433c594984f2cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad950974893a15479c433c594984f2cb9">&#9670;&#160;</a></span>parsed_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSBuf.html#ae27bdc0d7ad9a7aba6377e1a4a5af568">SBuf::size_type</a> Parser::Tokenizer::parsed_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="parser_2Tokenizer_8h_source.html#l00177">177</a> of file <a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="classParser_1_1Tokenizer.html#a8bce328442a3a568749270ea4c76080f">consume()</a>, <a class="el" href="classParser_1_1Tokenizer.html#a87363b6186ad71bc6298cad565dc7b5a">parsedSize()</a>, and <a class="el" href="classParser_1_1Tokenizer.html#a71043e213e4bddffe3bd27bc6a80e0b1">undoParse()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>squid/src/parser/<a class="el" href="parser_2Tokenizer_8h_source.html">Tokenizer.h</a></li>
<li>squid/src/parser/<a class="el" href="parser_2Tokenizer_8cc_source.html">Tokenizer.cc</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceParser.html">Parser</a></li><li class="navelem"><a class="el" href="classParser_1_1Tokenizer.html">Tokenizer</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
